[{"content":"fzfでコマンド履歴を便利に検索 コマンドラインでの作業を効率化するために、historyコマンドとfzfを組み合わせる方法を紹介します。\nfzf fzf は、コマンドラインでのインタラクティブな検索ツールです。fzfを使うことで、コマンドラインでの作業を効率化できます。fzfは、コマンドの出力をフィルタリングして表示できるため、目的のコマンドを素早く見つけることができます。\nfzfのインストール まず、fzfをインストールします。Homebrewを使用している場合、以下のコマンドでインストールできます。\nbrew install fzf パイプfzfで色々できます fzfは他のコマンドと組み合わせることで、さらに便利に使うことができます。例えば、以下のようにlsコマンドの出力をfzfでフィルタリングし、選択したディレクトリに移動できます。\nls | fzf また、以下のようにcdコマンドと組み合わせることで、選択したディレクトリに移動することも可能です。\ncd $(ls | fzf) このように、fzfをパイプで組み合わせることで、様々なコマンドの出力をインタラクティブにフィルタリングできます。\nhistory + fzf fzfは、コマンドラインでのインタラクティブな検索ツールです。historyコマンドと組み合わせることで、過去に実行したコマンドを素早く検索して再利用できます。以下のコマンドを実行することで、historyの出力をfzfでフィルタリングできます。\nhistory | fzf このコマンドを実行すると、過去のコマンド履歴が表示され、インクリメンタルサーチで目的のコマンドを素早く見つけることができます。\nショートカットキー fzfをさらに便利に使うために、ショートカットキーを設定できます。例えば、Ctrl + rキーを上書きして、history | fzfを実行するように設定できます。以下の設定を.bashrcや.zshrcに追加してください。\nbind '\u0026quot;\\C-r\u0026quot;: \u0026quot;history | fzf\\n\u0026quot;' この設定を追加することで、Ctrl + rキーを押すと、historyコマンドの出力をfzfでフィルタリングできるようになります。これにより、過去のコマンドを素早く検索して再利用できます。\n以上の方法を使って、fzfでコマンド履歴検索を便利にしましょう。コマンドラインでの作業効率が大幅に向上すること間違いなし！\n","date":"2024-10-08T16:50:23+09:00","image":"https://kseki.github.io/posts/history-fzf/covor.webp","permalink":"https://kseki.github.io/posts/history-fzf/","title":"作業効率アップ！fzfコマンドでコマンド履歴を便利に検索"},{"content":"概要 前回の GitHub Copilot Chatのプロンプトをスニペット化し、nvim-cmpと連携する方法 では、スニペットを使ってGitHub Copilot Chatのプロンプトを効率よく使う方法を紹介しました。今回は、Gitのコミットメッセージを生成してクリップボードにコピーする方法を紹介します。\n設定方法 以下の環境を前提に話を進めます。別の環境の場合は適宜読み替えてください。\n$ sw_vers ProductName: macOS ProductVersion: 14.6.1 BuildVersion: 23G93 $ nvim -v NVIM v0.10.1 Build type: Release LuaJIT 2.1.1723675123 CopilotChat.nvim branch canary commit 1a92bb6 CopilotChat.nvimの設定 以下のようなプロンプトを変数定義しておきます。\n1 2 3 4 5 6 7 8 9 10 local commit_staged_prompt = [[ 以下の条件を踏まえて変更に対するコミットメッセージを書いてください。 - コミットメッセージのprefixは、commitizenの規約に従ってください。 - コミットメッセージ本文は日本語で書いてください。 - タイトルは最大50文字、変更理由を含めてください。 - メッセージは72文字で折り返してください。 - メッセージ全体をgitcommit言語のコードブロックで囲んでください。 - ソースを見ても変更した理由がわからない時は、コミットメッセージを作る前に質問して、その回答も参考にコミットメッセージを生成してください。 ]] CopilotChat.nvimの設定ファイルに以下のように設定します。\n8行目にて、さっきのプロンプトを文字列結合して代入しています。 12~L17行目は、プロンプトの内容にコミットメッセージが含まれていた時にクリップボードにコピーするための設定です。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 return { \u0026#34;CopilotC-Nvim/CopilotChat.nvim\u0026#34;, branch = \u0026#34;canary\u0026#34;, cmd = \u0026#34;CopilotChat\u0026#34;, opts = { prompts = { CommitStaged = { prompt = \u0026#34;/COPILOT_GENERATE\u0026#34; .. commit_staged_prompt, selection = function(source) return select.gitdiff(source, true) end, callback = function(response, _) local commit_message = response:match(\u0026#34;```gitcommit(.-)```\u0026#34;) if commit_message then vim.fn.setreg(\u0026#34;+\u0026#34;, commit_message, \u0026#34;c\u0026#34;) end end, } } } } 使い方 実際に使っている様子をGIFで紹介します。 不要な変数を削除して、コミットメッセージを生成してクリップボードにコピーしています。 コピーしたコミットメッセージを使って、 LazyGit にてコミットを行います。\n一緒に読みたい記事 GitHub Copilot Chatのプロンプトをスニペット化し、nvim-cmpと連携する方法 NeovimでGitHub Copilot Chatを使う方法 ","date":"2024-08-27T17:16:17+09:00","image":"https://kseki.github.io/posts/neovim-github-copilot-chat-commit-message/cover.webp","permalink":"https://kseki.github.io/posts/neovim-github-copilot-chat-commit-message/","title":"NeovimでGitHub Copilot Chatでコミットメッセージを生成する方法"},{"content":"概要 前回の NeovimでGitHub Copilot Chatを使う方法 では、GitHub Copilot ChatをNeovimで使う方法を紹介しました。今回は、プロンプトをスニペット化し、nvim-cmpと連携して使う方法を紹介します。\n設計や実装の相談など、フォーマットは決まっているが中身が毎回変わるケースや、あらかじめプロンプトのフォーマットが決まっている場面ではスニペット化しておくと便利です。これにより、プロンプトエンジニアリングの効率が大幅に向上します。\n設定方法 以下の環境を前提に話を進めます。別の環境の場合は適宜読み替えてください。\n$ sw_vers ProductName: macOS ProductVersion: 14.6.1 BuildVersion: 23G93 $ nvim -v NVIM v0.10.1 Build type: Release LuaJIT 2.1.1723675123 nvim-cmp branch main commit ae644fe CopilotChat.nvim branch canary commit 1a92bb6 nvim-snippets branch main commit 56b4052 nvim-cmpの設定 nvim-cmpの設定を追加します。Copilot Chatのプロンプトがファイルタイプ copilot-chat なので、このファイルタイプに対して補完用のソースを追加します。\n1 2 3 4 5 6 7 8 9 local cmp = require(\u0026#34;cmp\u0026#34;) cmp.setup.filetype(\u0026#34;copilot-chat\u0026#34;, { sources = { { name = \u0026#34;snippets\u0026#34; }, { name = \u0026#34;copilot\u0026#34; }, { name = \u0026#34;buffer\u0026#34; }, }, }) nvim-snippetsの設定 以下の設定を追加します。\n※自分は nvim-snippets を使っていますが、他のスニペットプラグインを使っている場合はそのプラグインに合わせて設定してください。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 return { \u0026#34;garymjr/nvim-snippets\u0026#34;, opts = function(_, opts) opts.search_path = { \u0026#34;~/.config/nvim/snippets\u0026#34;, } end, keys = { { \u0026#34;\u0026lt;Leader\u0026gt;cp\u0026#34;, function() local filetype = vim.bo.filetype local path = string.format(\u0026#34;~/.config/nvim/snippets/%s.json\u0026#34;, filetype) vim.cmd(\u0026#34;e \u0026#34; .. path) end, desc = \u0026#34;Open snippets file\u0026#34;, }, }, } 次に、~/.config/nvim/snippets/copilot-chat.json にスニペットを追加します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;仕様相談\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;specon\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;以下の仕様について相談します。注意点・確認点があれば教えてください。\u0026#34;, \u0026#34;## 技術制約\u0026#34;, \u0026#34;- ${1:Ruby on Rails7}\u0026#34;, \u0026#34;## 仕様\u0026#34;, \u0026#34;- ${2:招待制ユーザー登録機能}\u0026#34; ] }, \u0026#34;ライブラリ選定\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;sllib\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;以下の仕様を実現するためのライブラリの候補をあげてください。\u0026#34;, \u0026#34;それぞれ、公式URL・メリット・デメリットを教えてください。\u0026#34;, \u0026#34;## 技術制約\u0026#34;, \u0026#34;- ${1:NPM}\u0026#34;, \u0026#34;## 仕様\u0026#34;, \u0026#34;- ${2:フォーマッター}\u0026#34; ] } } 以上で準備は完了です！\n使い方 動画で使い方を説明します。\nまとめ GitHub Copilot Chatとnvim-cmpを連携することで、プロンプト上でスニペットを活用できるようになります。これにより、設計や実装の相談が効率的に行えるようになります。プロンプトエンジニアリングの観点からも、非常に有用な手法です。ぜひ試してみてください。\n","date":"2024-08-20T16:11:47+09:00","image":"https://kseki.github.io/posts/github-copilot-chat-snippet/cover.webp","permalink":"https://kseki.github.io/posts/github-copilot-chat-snippet/","title":"GitHub Copilot Chatのプロンプトをスニペット化し、nvim-cmpと連携する方法"},{"content":"概要 複数のプロジェクトを同時に開発する際に、Nginxをリバースプロキシとして使用し、hostsファイルでローカルドメインを設定する方法を紹介します。\ngraph TD; A[ブラウザ] --\u003e|http://klog.local| B[Nginx] A --\u003e|http://admin.hoge.local| B A --\u003e|http://user.hoge.local| B B --\u003e|http://localhost:1313| C[klogプロジェクト] B --\u003e|http://localhost:3000| D[admin.hogeプロジェクト] B --\u003e|http://localhost:3001| E[user.hogeプロジェクト] 複数プロジェクト開発の問題 ローカル開発環境では通常、ブラウザに localhost:ポート番号 を入力してアクセスします。しかし、複数のプロジェクトを開発していると、ブラウザのアドレスバーに localhost と入力した際に他のプロジェクトのパスがサジェストされてしまい、煩わしいことがあります。\n※単にhostsファイルにドメインを設定するだけで上記問題は解決できます。大袈裟ではありますが、今回は勉強がてらNginxのリバースプロキシを設定しました。\n設定方法 以下の環境を前提に話を進めます。別の環境の場合は適宜読み替えてください。\n$ sw_vers ProductName: macOS ProductVersion: 14.5 BuildVersion: 23F79 $ brew -v Homebrew 4.3.15-52-ge590bca Homebrew/homebrew-cask (git revision 7adc70cd367; last commit 2024-08-04) $ nginx -v nginx version: nginx/1.27.0 Hostsファイルにローカルドメインを設定する sudo vim /etc/hosts 以下のように、127.0.0.1に対して対象としたいプロジェクト用のローカルドメインを設定します。\n1 2 3 4 5 6 7 8 9 10 11 ## # Host Database # # localhost is used to configure the loopback interface # when the system is booting. Do not change this entry. ## 127.0.0.1\tlocalhost + # 技術ブログ + 127.0.0.1 klog.local + # hogeプロジェクト + 127.0.0.1\tadmin.hoge.local user.hoge.local Nginxのインストール brew install nginx Nginxの起動 nginx Nginxの設定 Nginxの設定ファイルである /usr/local/etc/nginx/nginx.conf を確認すると、 include servers/* とあります。 このディレクトリに設定ファイルを追加すれば読み込んでくれます。\nhttp { # ~ 省略 ~ include servers/*; } /usr/local/etc/nginx/servers/ に klog.conf というファイルを作成し、以下の内容で保存します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 + server { + listen 80; + server_name klog.local; + + location / { + proxy_pass http://localhost:1313; + proxy_http_version 1.1; + proxy_set_header Upgrade $http_upgrade; + proxy_set_header Connection \u0026#34;upgrade\u0026#34;; + proxy_set_header Host $host; + proxy_set_header X-Real-IP $remote_addr; + proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; + proxy_set_header X-Forwarded-Proto $scheme; + } + } hogeプロジェクトの分。hoge.conf も追加します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 + server { + listen 80; + server_name admin.hoge.local; + + location / { + proxy_pass http://localhost:3000; + proxy_http_version 1.1; + proxy_set_header Upgrade $http_upgrade; + proxy_set_header Connection \u0026#34;upgrade\u0026#34;; + proxy_set_header Host $host; + proxy_set_header X-Real-IP $remote_addr; + proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; + proxy_set_header X-Forwarded-Proto $scheme; + } + } + + server { + listen 80; + server_name user.hoge.local; + + location / { + proxy_pass http://localhost:3001; + proxy_http_version 1.1; + proxy_set_header Upgrade $http_upgrade; + proxy_set_header Connection \u0026#34;upgrade\u0026#34;; + proxy_set_header Host $host; + proxy_set_header X-Real-IP $remote_addr; + proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; + proxy_set_header X-Forwarded-Proto $scheme; + } + } 設定ファイルが正しいかを確認します。以下のコマンドを実行し、エラーがなければOKです。\nnginx -t 設定を反映させるためにNginxをリロードします。\nnginx -s reload ブラウザでアクセスする 設定が完了したら、ブラウザで http://kseki.local にアクセスして動作を確認します。\n正常に表示されれば成功です！お疲れ様でした。\n注意点 開発サーバーはポートを指定して起動すること。使用ポートを固定しないと、ポートが変わってしまった時に設定を変更する手間がかかります。\n例えばHugoの場合、ファイル保存時にWebSocketを使って画面を更新しているので、ポート指定しないと自動更新されなくなってしまいます。\n# Hugoの場合 hugo server --port=1313 --liveReloadPort=80 # Railsの場合 bundle exec rails -b 30001 以上で、Nginxを使用したローカルドメインの設定方法についての説明を終わります。これにより、複数のプロジェクトを効率的に開発できるようになります。\n","date":"2024-08-13T16:14:17+09:00","image":"https://kseki.github.io/posts/%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%81%A8nginx%E3%81%A7%E8%A4%87%E6%95%B0%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E9%96%8B%E7%99%BA%E3%82%92%E4%BE%BF%E5%88%A9%E3%81%AB/nginx.webp","permalink":"https://kseki.github.io/posts/%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%81%A8nginx%E3%81%A7%E8%A4%87%E6%95%B0%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E9%96%8B%E7%99%BA%E3%82%92%E4%BE%BF%E5%88%A9%E3%81%AB/","title":"ローカルドメインとNginxで複数プロジェクト開発を便利に"},{"content":"概要 先日、あるプロジェクトで配列の要素をランダムにシャッフルする必要がありました。TypeScript (5.5.4) には組み込みの shuffle 関数がないため、自分で実装する必要がありました。この記事では、その際に調べたフィッシャーイェーツのシャッフルアルゴリズムについて解説します。\nRubyの配列シャッフル実装 RubyにはArryクラスにsuffle, suffle! という関数があります。\nこれらの関数は、以下のC言語で書かれているrb_ary_suffle_bang 関数を呼び出しています。\nこの関数のアルゴリズムはフィッシャーイェーツのシャッフルと言われるものです。特徴は以下の通りです：\nランダム性: 配列の各要素が等しい確率で任意の位置に移動する。 インプレース: 配列の要素をその場でシャッフルし、追加のメモリをほとんど使用しない。 時間計算量: O(n)の時間でシャッフルを完了する。 安定性: 元の順序を保持しないため、安定なソートではない。 シンプルな実装: アルゴリズムはシンプルで理解しやすい。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static VALUE rb_ary_shuffle_bang(rb_execution_context_t *ec, VALUE ary, VALUE randgen) { long i, len; rb_ary_modify(ary); i = len = RARRAY_LEN(ary); RARRAY_PTR_USE(ary, ptr, { while (i) { long j = RAND_UPTO(i); VALUE tmp; if (len != RARRAY_LEN(ary) || ptr != RARRAY_CONST_PTR(ary)) { rb_raise(rb_eRuntimeError, \u0026#34;modified during shuffle\u0026#34;); } tmp = ptr[--i]; ptr[i] = ptr[j]; ptr[j] = tmp; } }); /* WB: no new reference */ return ary; } TypeScriptで配列シャッフル実装 この関数は、配列の要素をランダムにシャッフルし、元の配列を変更します。フィッシャーイェーツのアルゴリズムを使用しているため、効率的かつ簡単に実装できます。\n1 2 3 4 5 6 7 const shuffleArray = (array: string[]) =\u0026gt; { for (let i = array.length - 1; i \u0026gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; } おみくじの実装例 上記の関数を使っておみくじを実装してみました。\nフィッシャーイェーツ関数でおみくじ | Playground Link\n","date":"2024-08-06T16:33:05+09:00","image":"https://kseki.github.io/posts/shuffle-algorithm-by-typescript/cover.webp","permalink":"https://kseki.github.io/posts/shuffle-algorithm-by-typescript/","title":"TypeScriptでフィッシャーイェーツのアルゴリズムを使って配列をシャッフルする方法"},{"content":"AWS環境で運用しているアプリケーションは、複数のアカウントや異なるリージョンで構築されることがあります。この記事では、そのような状況でAWS RDSのスナップショットを共有し、復元する方法を詳しく説明します。\n作業概要 以下のような複数アカウント・複数リージョン運用のケース。\nアカウントA: 東京リージョン アカウントB: オレゴンリージョン アカウントAの東京リージョンの暗号化しているRDSインスタンスのスナップショットを、アカウントBのオレゴンリージョンで復元したい。\n忙しい人の為の手順書 アカウントAにて\n対象RDSインスタンスのスナップショットをとる アカウントBと共有するカスタマー管理キーをマルチリージョンで作成する 上記のカスタマー管理キーのレプリカをオレゴンリージョンに作成する スナップショットを手順2にて作成したカスタマー管理キーでオレゴンリージョンにコピーする 手順4でコピーしたスナップショットをアカウントBに共有する 3で作成したレプリカのカスタマー管理キーをアカウントBに共有する アカウントBにて\nオレゴンリージョンのRDS共有スナップショットを確認する 手順1の共有スナップショットをコピーする 共有スナップショットを復元できませんが、コピーすることで復元可能になります。 手順2にてコピーしたスナップショットを復元する スナップショット移行の手順 アカウントAで作業 スナップショットの作成 アカウントAで対象となるRDSインスタンスのスナップショットを作成します。\nKMSカスタマー管理型のキーの作成 アカウントAでアカウントBと共有するマルチリージョン対応のKMSキーを東京リージョンで作成します。\nKMS \u0026gt; カスタマー管理型のキー \u0026gt; キーの作成 KMSカスタマー管理型のキーのレプリカ作成 アカウントAにて、東京リージョンで作成したキーのレプリカをオレゴンリージョンで作成します。\nKMS \u0026gt; カスタマー管理型のキー \u0026gt; キー ID: XXXXXXXXXXXXXXX 関連するマルチリージョンキー \u0026gt; 新しいレプリカキーを作成\nオレゴンリージョンを選択する。\nスナップショットのコピー アカウントAで作成したスナップショットを、手順2で作成したKMSキーを使用してオレゴンリージョンにコピーします。\nRDS \u0026gt; スナップショット \u0026gt; スナップショットをコピー\nAWS KMSキーに上で作成したキーを指定する。\nスナップショットの共有 アカウントAでコピーしたスナップショットをアカウントBと共有します。\nAWSアカウントIDに、アカウントBのIDを入力する。\nKMSキーの共有 アカウントAで作成したレプリカのカスタマー管理キーをアカウントBに共有する。\nアカウントBのIDを入力する。\nアカウントBで作業 オレゴンリージョンのRDS共有スナップショットの確認 共有スナップショットが参照できるか確認します。\n共有スナップショットのコピー アカウントBで共有されたスナップショットをコピーします。\nAmazonリソースネーム(ARN): 先ほど共有したレプリカのカスタマー管理キーのARNを入力する。\nスナップショットのリストア アカウントBでコピーしたスナップショットをリストアします。\nこの手順により、AWS RDSのスナップショットを異なるアカウントとリージョン間で移行することが可能となります。\n失敗から学ぶRDBの正しい歩き方 (Software Design plus) Amazonで購入 ","date":"2024-07-30T16:40:32+09:00","image":"https://kseki.github.io/posts/aws-rds-snapshot-migration/cover.webp","permalink":"https://kseki.github.io/posts/aws-rds-snapshot-migration/","title":"AWS RDSスナップショットのマルチアカウント・マルチリージョン移行方法"},{"content":"概要 この記事では、Neovimのhop.nvimプラグインについて説明します。hop.nvimはカーソル移動のプラグインで、できるだけ少ないキー操作で任意の場所にジャンプできるようになります。以下では、その設定方法と具体的な使用例について詳しく説明します。\n設定 自分の設定例です。プラグイン管理がLazyの場合は、以下のように設定できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 return { \u0026#34;smoka7/hop.nvim\u0026#34;, event = \u0026#34;BufRead\u0026#34;, version = \u0026#34;*\u0026#34;, opts = { multi_windows = true, }, keys = { { \u0026#34;\u0026lt;leader\u0026gt;w\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;HopWord\u0026lt;CR\u0026gt;\u0026#34;, mode = \u0026#34;n\u0026#34;, desc = \u0026#34;Hop Word\u0026#34; }, { \u0026#34;\u0026lt;leader\u0026gt;l\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;HopLine\u0026lt;CR\u0026gt;\u0026#34;, mode = \u0026#34;n\u0026#34;, desc = \u0026#34;Hop Line\u0026#34; }, { \u0026#34;\u0026lt;leader\u0026gt;c\u0026#34;, \u0026#34;\u0026lt;cmp\u0026gt;HopChar1\u0026lt;CR\u0026gt;\u0026#34;, mode = \u0026#34;n\u0026#34;, desc = \u0026#34;Hop Char\u0026#34; }, { \u0026#34;\u0026lt;leader\u0026gt;p\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;HopPattern\u0026lt;CR\u0026gt;\u0026#34;, mode = \u0026#34;n\u0026#34;, desc = \u0026#34;Hop Pattern\u0026#34; }, { \u0026#34;f\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;HopChar1CurrentLineAC\u0026lt;CR\u0026gt;\u0026#34;, mode = { \u0026#34;n\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;o\u0026#34; }, desc = \u0026#34;Hop Char in Line (After Cursor)\u0026#34; }, { \u0026#34;F\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;HopChar1CurrentLineBC\u0026lt;CR\u0026gt;\u0026#34;, mode = { \u0026#34;n\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;o\u0026#34; }, desc = \u0026#34;Hop Char in Line (Before Cursor)\u0026#34; }, { \u0026#34;t\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;lua require\u0026#39;hop\u0026#39;.hint_char1({ direction = require\u0026#39;hop.hint\u0026#39;.HintDirection.AFTER_CURSOR, current_line_only = true, hint_offset = -1 })\u0026lt;CR\u0026gt;\u0026#34;, mode = { \u0026#34;n\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;o\u0026#34; }, desc = \u0026#34;Hop Before Char in Line (After Cursor)\u0026#34;, }, { \u0026#34;T\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;lua require\u0026#39;hop\u0026#39;.hint_char1({ direction = require\u0026#39;hop.hint\u0026#39;.HintDirection.BEFORE_CURSOR, current_line_only = true, hint_offset = 1 })\u0026lt;CR\u0026gt;\u0026#34;, mode = { \u0026#34;n\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;o\u0026#34; }, desc = \u0026#34;Hop After Char in Line (Before Cursor)\u0026#34;, }, }, } 使い方 HopWord: 画面上の特定の単語の先頭にジャンプしたい時 8行目のkeysの上にカーソルがあります。そこから7行上のreturnの先頭にカーソルをジャンプしたい時の例です。 コマンド的には、\u0026lt;Space\u0026gt;w, yでジャンプしています。\nステップで説明すると以下です。\nreturnより11行下のmodeに目線を移す。 \u0026lt;Space\u0026gt;w（HopWordコマンド実行キーマップ）をタイプ 目線にあるハイライトされた文字ngをタイプして移動完了 HopLine: 特定の行に直接ジャンプしたい時 現在、カーソルが8行目のkeysの上にあります。そこから7行上のreturnの行にカーソルをジャンプしたい時の例です。 コマンド的には、\u0026lt;Space\u0026gt;l, yでジャンプしています。\nステップで説明すると以下です。\nkeysより7行下のreturnに目線を移す。 \u0026lt;Space\u0026gt;l（HopLineコマンド実行キーマップ）をタイプ 目線にあるハイライトされた文字yをタイプして移動完了 HopChar1: 画面上の特定の文字にジャンプしたい時 現在、カーソルが1行目のreturnの上にあります。そこから18行下のHop Before Char ...の行の先頭にジャンプしたい時の例です。 コマンド的には、\u0026lt;Space\u0026gt;c, H, \u0026lt;Enter\u0026gt;, rでジャンプしています。\nHopPattern: 画面上の特定のパターンにジャンプしたい時 現在、カーソルが1行目のreturnの上にあります。そこから16行下のHintDirectionのDの位置にジャンプしたときの例です。\nステップで説明すると以下です。\nreturnより16行下のHintDirectionのDの位置に目線を移す。 \u0026lt;Space\u0026gt;p（HopPatternコマンド実行キーマップ）をタイプ ジャンプしたいパターンdireactionをタイプ 目線にあるハイライトされた文字sをタイプして移動完了 まとめ この記事では、Neovimのhop.nvimプラグインの設定方法と使用例について説明しました。hop.nvimは、少ないキー操作で任意の場所にジャンプすることを可能にする強力なカーソル移動ツールです。\nHopWord, HopLine, HopChar1, そして HopPatternといった主要なコマンドを使用することで、効率的にコードをナビゲートできます。これらのコマンドは、特定の単語、行、文字、またはパターンにジャンプするためのものです。\nさらに、hop.nvimにはこれら以外にも多くの機能と設定オプションがあります。例えば、異なるウィンドウ間でのジャンプや、カーソル位置に基づいたジャンプなどが可能です。詳細は公式GitHubリポジトリを参照してください。\nこのプラグインを活用することで、あなたのコーディング体験はさらに向上するでしょう。\n実践Vim　思考のスピードで編集しよう！ (アスキー書籍) Amazonで購入 ","date":"2024-07-16T16:50:23+09:00","image":"https://kseki.github.io/posts/hop-nvim/hop-cover.png","permalink":"https://kseki.github.io/posts/hop-nvim/","title":"Neovim hop.nvimで爆速移動"},{"content":"はじめに 東京都デジタルサービス局が発行した「AI活用事例集」を読みました。 AI技術がどのように行政の現場で活用されているのかを知ることができる非常に興味深い内容でした。この記事では、私が特に面白いと感じた事例をいくつか紹介し、それに対する感想を述べたいと思います。\n都職員のアイデアが詰まった文章生成AI活用事例集|ICT導入・活用の推進|東京都デジタルサービス局\n面白かった事例集 政策のアイデア案を出しリスクを確認する この事例では、AIを活用して政策のアイデアを生成し、そのリスクを確認するプロセスが紹介されていました。AIは過去のデータや類似事例を参照しながら、政策のアイデアを出します。また、見落としがちなリスクを事前に把握できる点が非常に有用だと思いました。\nリスクの洗い出しは抜け漏れが無いように実際の業務でもAIを使って洗い出しを行いたいと思いました。\n研修の理解度を確認するためのテスト問題を作成する AIを活用して研修の理解度を確認するためのテスト問題を自動生成する事例です。 テスト問題を作成にあたって、指示・条件・ゴールを細かく指定していて、AI回答の回答が的確に出力されています。 4択問題の間違った選択肢を考えるのは結構たいへんだと思うので良い使い方だと思いました。\n適切なフレーズを提案してもらう 文章作成の際、適切なフレーズが見当たらないときや、既に思いついているが他のアイデアを探したいときに表現の提案をしてもらう事例です。\n開発の場合も、文言の作成に迷うことが多々あるので活用したいと思いました。\n感想 「東京都デジタルサービス局のAI活用事例集」から活用事例を紹介しました。 この資料では、活用事例だけではなく、プロンプトのコツや、AIを実際に利用した職員のアンケート結果も載っていて非常に有用な資料でした。この事例集は、他の自治体や企業にとっても参考になる内容が多く含まれており、今後のAI活用の可能性を示唆するものでした。是非読んでみてください！\n","date":"2024-07-09T17:00:38+09:00","image":"https://kseki.github.io/posts/tokyo-metropolitan-governments-ai-use-case/cover.webp","permalink":"https://kseki.github.io/posts/tokyo-metropolitan-governments-ai-use-case/","title":"東京都デジタルサービス局のAI活用事例集に見るChatGPTプロンプト例"},{"content":"Tabnineとは Tabnineは、AIを活用したコード補完プラグインです。従来の補完機能よりも高度な機能を提供し、コード開発を効率化します。Tabnineは、GPT-3と呼ばれる強力なAIモデルを使用しています。このモデルは、大量のコードを学習し、その結果を元にコード補完を提供します。\n主な機能は以下の通りです。\nコンテキストに応じた補完: Tabnineは、あなたが書いているコードの文脈を理解し、最も適切な補完候補を提案します。これは、あなたが何をしようとしているかをAIが理解し、それに基づいて最適なコードスニペットを提供することを意味します。\nコード生成: Tabnineは、関数やクラスの定義、テストコードなど、様々なコードを自動生成できます。これは、あなたが新しい関数を作成しようとしているとき、Tabnineがその関数のスケルトンを生成することを意味します。\nコード検索: Tabnineは、コード内の変数や関数の定義箇所を素早く検索できます。これは、あなたが特定の関数の定義を探しているとき、Tabnineがその関数の定義を素早く見つけることを意味します。\nマルチ言語対応: Tabnineは多くのプログラミング言語に対応しており、様々な言語間で補完やコード生成を行うことができます。これは、あなたがPythonでコードを書いているときでも、Javaでコードを書いているときでも、Tabnineが適切な補完を提供することを意味します。\nNeovimにインストールする方法 今回はhrsh7th/nvim-cmpのソースとしてにTabnineをインストールします。\nプラグインを追加\n1 2 3 4 5 6 7 return require(\u0026#34;packer\u0026#34;).startup( use({ \u0026#39;tzachar/cmp-tabnine\u0026#39;, run=\u0026#39;./install.sh\u0026#39;, requires = \u0026#39;hrsh7th/nvim-cmp\u0026#39;, }) ) 設定を追加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 require(\u0026#39;cmp_tabnine.config\u0026#39;).setup({ max_lines = 1000, max_num_results = 20, sort = true, run_on_every_keystroke = true, snippet_placeholder = \u0026#39;..\u0026#39;, ignored_file_types = { -- default is not to ignore -- uncomment to ignore in lua: -- lua = true }, show_prediction_strength = false, min_percent = 0 }) cmpのソースとして追加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 表示する文字色を紫色に設定 vim.api.nvim_set_hl(0, \u0026#34;CmpItemKindTabNine\u0026#34;, { fg = \u0026#34;#7A00FF\u0026#34; }) require(\u0026#39;cmp\u0026#39;).setup({ snippet = { expand = function(args) luasnip.lsp_expand(args.body) end, }, sources = cmp.config.sources({ { name = \u0026#34;copilot\u0026#34; }, -- GitHub Copilot { name = \u0026#34;cmp_tabnine\u0026#34; }, -- Tabnine { name = \u0026#34;luasnip\u0026#34; }, -- snippet { name = \u0026#34;buffer\u0026#34; }, -- text within current buffer { name = \u0026#34;path\u0026#34; }, -- file system paths }), formatting = { format = lspkind.cmp_format({ maxwidth = 200, ellipsis_char = \u0026#34;...\u0026#34;, symbol_map = { TabNine = \u0026#34;\u0026#34;, }, }), }, }) まとめ この記事では、NeovimでTabnineを設定し、使用する方法について説明しました。TabnineはAIを活用したコード補完プラグインで、コードの文脈を理解し、最も適切な補完候補を提案します。また、コード生成、コード検索、マルチ言語対応などの機能も提供します。\nTabnineを使用することで、コードの品質を向上させ、開発効率を大幅に改善できます。これにより、より複雑な問題に集中し、より創造的なソリューションを開発する時間が増えます。\n今後もTabnineのようなツールを活用して、コーディングの効率と楽しさを最大限に引き出していきましょう。\n参考 tzachar/cmp-tabnine: TabNine plugin for hrsh7th/nvim-cmp Install Tabnine for Neovim | Tabnine AI code assistant ","date":"2024-07-02T16:38:00+09:00","permalink":"https://kseki.github.io/posts/cmp-tabnine-nvim/","title":"NeovimでTabnineを使う方法"},{"content":"概要 Amazon S3のファイルへのアクセスログをAmazon Athenaで確認する方法です。\nステップ1: S3バケットのサーバーアクセスログを有効にする まず、S3バケットでサーバーアクセスログを有効にする必要があります。これにより、アクセスされるたびにログが記録され、後で分析するために使用できます。\nステップ2: Amazon Athenaコンソールを開く 次に、Amazon Athenaコンソールにアクセスし、クエリエディタを使用してデータベースとテーブルを作成します。\nステップ3: データベースを作成する Athenaで新しいデータベースを作成し、アクセスログデータの格納場所として設定します。 今回は、デフォルトで用意されているdefaultを使います。\nステップ4: テーブルスキーマを作成する アクセスログデータの構造を定義するテーブルスキーマを作成します。 以下のクエリを実行します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 CREATE EXTERNAL TABLE `default.\u0026lt;データベース名\u0026gt;`( `bucketowner` STRING, `bucket_name` STRING, `requestdatetime` STRING, `remoteip` STRING, `requester` STRING, `requestid` STRING, `operation` STRING, `key` STRING, `request_uri` STRING, `httpstatus` STRING, `errorcode` STRING, `bytessent` BIGINT, `objectsize` BIGINT, `totaltime` STRING, `turnaroundtime` STRING, `referrer` STRING, `useragent` STRING, `versionid` STRING, `hostid` STRING, `sigv` STRING, `ciphersuite` STRING, `authtype` STRING, `endpoint` STRING, `tlsversion` STRING, `accesspointarn` STRING, `aclrequired` STRING) ROW FORMAT SERDE \u0026#39;org.apache.hadoop.hive.serde2.RegexSerDe\u0026#39; WITH SERDEPROPERTIES ( \u0026#39;input.regex\u0026#39;=\u0026#39;([^ ]*) ([^ ]*) \\\\[(.*?)\\\\] ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) (\\\u0026#34;[^\\\u0026#34;]*\\\u0026#34;|-) (-|[0-9]*) ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) (\\\u0026#34;[^\\\u0026#34;]*\\\u0026#34;|-) ([^ ]*)(?: ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*))?.*$\u0026#39;) STORED AS INPUTFORMAT \u0026#39;org.apache.hadoop.mapred.TextInputFormat\u0026#39; OUTPUTFORMAT \u0026#39;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\u0026#39; LOCATION \u0026#39;s3://\u0026lt;S3バケット名\u0026gt;/\u0026lt;ディレクトリ\u0026gt;/\u0026#39; ステップ5: テーブルをプレビューする 作成したテーブルスキーマが正しく機能しているかを確認するために、テーブルのプレビューを行います。\nステップ6: クエリを実行する 最後に、Athenaのクエリエディタを使用して、特定の条件に基づいてログデータをクエリします。例えば、特定のオブジェクトに対するDELETE操作や、特定のエラーコードを持つリクエストを検索できます。\n特定のオブジェクトの特定期間のGETログを見る 1 2 3 4 5 6 7 SELECT * FROM default.\u0026lt;データベース名\u0026gt; WHERE Key=\u0026#39;prefix/images/picture.jpg\u0026#39; AND operation=\u0026#39;REST.GET.OBJECT\u0026#39; AND parse_datetime(requestdatetime,\u0026#39;dd/MMM/yyyy:HH:mm:ss Z\u0026#39;) BETWEEN parse_datetime(\u0026#39;2024-06-18:07:00:00\u0026#39;,\u0026#39;yyyy-MM-dd:HH:mm:ss\u0026#39;) AND parse_datetime(\u0026#39;2024-06-18:08:00:00\u0026#39;,\u0026#39;yyyy-MM-dd:HH:mm:ss\u0026#39;); 参考 Amazon S3 アクセスログを使用したリクエストの識別 - Amazon Simple Storage Service AWSの基本・仕組み・重要用語が全部わかる教科書 (見るだけ図解) Amazonで購入 ","date":"2024-06-25T16:31:19+09:00","image":"https://kseki.github.io/posts/s3-access-log-with-athena/aws-athena.webp","permalink":"https://kseki.github.io/posts/s3-access-log-with-athena/","title":"AWS S3のファイルへのアクセスログをAthenaで確認する方法"},{"content":"概要 Lazygitは、開発者の生産性を向上させるために設計された、コマンドラインツールです。このツールは、Gitの操作を簡単かつ効率的に行うことができるインターフェースを提供します。ステータスの確認、コミットの作成、ブランチの切り替えなどの一般的なGit操作を簡単に行うことができます。\nインストール方法 MacOSユーザーは、Homebrewを使用してLazygitを簡単にインストールできます。ターミナルを開き、以下のコマンドを実行します。\n1 brew install lazygit ※他のインストール方法はこちら\nチュートリアル READMEにチュートリアル動画へのリンクがあるので一度やってみることをお勧めします！\nGitHubと連携して一連の開発作業のやり方 Lazygitを使用してGitHubと連携し、開発作業を行うプロセスは以下の通りです。\nブランチを作成 リポジトリ内で新しいブランチを作成し、特定の機能や修正に取り組みます。 ベースブランチの上にカーソルを合わせて c を押すとダイアログが表示されるので、ブランチ名を入力して Enter を押すだけです。\nファイルを編集してコミット 必要なファイルを編集し、変更をコミットします。Lazygitでは、変更をステージングし、コミットメッセージを入力することが容易です。 コミットしたいディレクトリ、またはファイルにカーソルを合わせて Space を押してステージング。 c を押すとダイアログが表示されるのでコミットメッセージを入力して Enter キーを押す。\nリモートリポジトリーにpush、PRの作成 コミットした変更をリモートリポジトリにpushします。GitHub上でPRを作成します。 Pushしたいリポジトリにカーソルを合わせて P を押し Enter するだけです。（リモートリポジトリが存在する場合は p でOKです。） Pushが終わったら、PR作成したいリポジトリにカーソルを合わせてoを押すと、ブラウザでPR作成画面が表示されます。\n他にも たくさんの機能 や カスタムコマンド を追加出来ます！\nまとめ Lazygitは、Gitの操作を簡単にし、開発者の作業を効率化する強力なツールです。その直感的なUIと豊富な機能により、開発プロセスがよりスムーズになります。この記事がLazygitの導入と利用の手助けになれば幸いです。\n参考 jesseduffield/lazygit: simple terminal UI for git commands ","date":"2024-06-18T16:21:07+09:00","image":"https://kseki.github.io/posts/how_to_lazygit/lazygit.png","permalink":"https://kseki.github.io/posts/how_to_lazygit/","title":"便利なGitコマンドラインツールLazygit"},{"content":"概要 GitHub Copilot Chatは、開発者がコーディング中にリアルタイムで支援を受けることができるツールです。 copilot.vim を使えばNeovimでもGitHub Copilotは使えるのですが、まだChatには対応していません。 Neovimエディタで利用することで、コードの自動補完やドキュメントの参照、コーディングの疑問点を解決するための対話が可能になります。\nCopilotChat.nvim を使うことでChatを利用できるようになります。\n設定方法 1. プラグインをインストールする まずプラグインをインストールする必要があります。お使いのプライグインマネージャーに応じて設定してください。 自分の環境は vim-plug なので下記を追加しました。\n1 2 3 4 5 6 7 8 9 call plug#begin() Plug \u0026#39;zbirenbaum/copilot.lua\u0026#39; Plug \u0026#39;nvim-lua/plenary.nvim\u0026#39; Plug \u0026#39;CopilotC-Nvim/CopilotChat.nvim\u0026#39;, { \u0026#39;branch\u0026#39;: \u0026#39;canary\u0026#39; } call plug#end() lua \u0026lt;\u0026lt; EOF require(\u0026#34;CopilotChat\u0026#34;).setup {} EOF その後、 :PackerSync コマンドを実行しインストール後にNeovimを再起動すると完了です。\n2. GitHub Copilot Chatが日本語で回答するように設定する 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 lua \u0026lt;\u0026lt; EOF require(\u0026#34;CopilotChat\u0026#34;).setup({ show_help = \u0026#34;yes\u0026#34;, prompts = { Explain = { prompt = \u0026#34;/COPILOT_EXPLAIN アクティブな選択範囲の説明を段落形式で書いてください。日本語で返答ください。\u0026#34;, }, Review = { prompt = \u0026#34;/COPILOT_REVIEW 選択されたコードをレビューしてください。日本語で返答ください。\u0026#34;, }, FixCode = { prompt = \u0026#34;/COPILOT_GENERATE このコードには問題があります。バグを修正したコードに書き直してください。日本語で返答ください。\u0026#34;, }, Refactor = { prompt = \u0026#34;/COPILOT_GENERATE 明瞭性と可読性を向上させるために、次のコードをリファクタリングしてください。日本語で返答ください。\u0026#34;, }, BetterNamings = { prompt = \u0026#34;/COPILOT_GENERATE 選択されたコードの変数名や関数名を改善してください。日本語で返答ください。\u0026#34;, }, Documentation = { prompt = \u0026#34;/COPILOT_GENERATE 選択範囲にドキュメントコメントを追加してください。日本語で返答ください。\u0026#34;, }, Tests = { prompt = \u0026#34;/COPILOT_GENERATE コードのテストを生成してください。日本語で返答ください。\u0026#34;, }, Wording = { prompt = \u0026#34;/COPILOT_GENERATE 次のテキストの文法と表現を改善してください。日本語で返答ください。\u0026#34;, }, Summarize = { prompt = \u0026#34;/COPILOT_GENERATE 選択範囲の要約を書いてください。日本語で返答ください。\u0026#34;, }, Spelling = { prompt = \u0026#34;/COPILOT_GENERATE 次のテキストのスペルミスを修正してください。日本語で返答ください。\u0026#34;, }, FixDiagnostic = { prompt = \u0026#34;ファイル内の次の問題を支援してください:\u0026#34;, selection = select.diagnostics, }, Commit = { prompt = \u0026#34;変更のコミットメッセージをcommitizenの規約に従って日本語で書いてください。タイトルは最大50文字、メッセージは72文字で折り返してください。メッセージ全体をgitcommit言語のコードブロックで囲んでください。\u0026#34;, selection = select.gitdiff, }, CommitStaged = { prompt = \u0026#34;変更のコミットメッセージをcommitizenの規約に従って日本語で書いてください。タイトルは最大50文字、メッセージは72文字で折り返してください。メッセージ全体をgitcommit言語のコードブロックで囲んでください。\u0026#34;, selection = function(source) local select = require(\u0026#34;CopilotChat.select\u0026#34;) return select.gitdiff(source, true) end, }, }, }) EOF COPILOT_EXPLAIN などはデフォルトでプロンプトの内容が定数化されています。(詳しくは、 prompts.lua を参照ください。) 続けて日本語で説明してもらうようにプロンプトを追加しています。\n使い方 使い方はいろいろありますが、今回は、 :CopilotChatTests コマンドを使ってテストを作成してもらう方法を書きます。\n対象となるコードをヤンクする コマンドモードで :CopilotChatTests を入力するとChatが返ってくる チャット画面で g + y をしてテストコードをヤンクする テストファイルに p でペースト で完成です。\nまとめ GitHub Copilot Chatは開発者にとって強力な支援ツールです。このツールを活用することで、開発の効率化とコーディングの質の向上が期待できます。\nこのポストは、NeovimでGitHub Copilot Chatを使う方法についての概要を提供しています。より詳細な情報やサポートが必要な場合は、公式ドキュメントやコミュニティフォーラムを参照してください。開発の旅において、GitHub Copilot Chatが有益なガイドとなることを願っています。\nChatGPT超実践活用法: 【GPT-4対応版】【code interpreter解説有】｢ビジネスシーン｣におけるマジで使える利用方法25選【使い方・入門・教科書・初心者・利用法】 ChatGPT・IT・テクノロジー (AI技術・テクノロジー・人工知能) Amazonで購入 エンジニアのためのChatGPT活用入門 AIで作業負担を減らすためのアイデア集 Amazonで購入 ","date":"2024-04-09T16:30:42+09:00","image":"https://kseki.github.io/posts/github-copilot-chat-nvim/copilot-chat-demo.jpg","permalink":"https://kseki.github.io/posts/github-copilot-chat-nvim/","title":"NeovimでGitHub Copilot Chatを使う方法"},{"content":"概要 プログラミングにおいて、テストカバレッジはコードの品質を保証する重要な指標の1つです。特に、大規模なプロジェクトや多くの開発者が関わるプロジェクトでは、変更が頻繁に行われるため、新たなコードが既存のテストによって適切にカバーされているかを確認することが不可欠です。\nこのブログポストでは、undercover gemを使用して、プルリクエスト（PR）毎にDiffカバレッジを計測し、継続的インテグレーション（CI）で監視する方法について解説します。\n背景 プロジェクトにアサインされた際、テストカバレッジの低さがバグの多さに直結していることに気づくことは珍しくありません。テストカバレッジを上げることは、バグを減らし、ソフトウェアの品質を向上させるために重要です。しかし、Simplecovだけでは、全体のテストカバレッジしか測定できず、変更点に対するカバレッジを把握できません。これでは、新たなコードが適切にテストされているかを確認することが困難です。\nここで役立つのが、undercover gemです。このgemを使用すると、PR毎に変更されたコードに対するテストカバレッジ、すなわちDiffカバレッジを計測できます。これにより、CIツール内での監視が可能になり、新しいコードが十分にテストされていることを保証できます。\nDiffカバレッジを計測することの利点は、開発者が新しいコードに対するテストを怠らないように促すことです。また、レビュアーがコードレビューする際に、テストが適切に行われているかを確認するための指標としても機能します。さらに、テストカバレッジを徐々に上げることで、プロジェクト全体の品質を向上させることができます。\n設定方法 undercover gemを使ったDiffカバレッジの計測方法は以下の通りです。\nGemfileにundercoverを追加し、bundle installを実行します。 undercoverが対応しているのはLCOV形式なので、simplecov-lcovも一緒にインストールします。\n1 2 3 4 5 6 # Gemfile group :test do gem \u0026#39;simplecov\u0026#39;, require: false gem \u0026#39;simplecov-lcov\u0026#39;, require: false gem \u0026#39;undercover\u0026#39;, require: false end 次にsimplecovの設定を追加します。\n1 2 3 4 5 6 7 8 9 # spec/rails_helper.rb require \u0026#39;simplecov\u0026#39; require \u0026#39;simplecov-lcov\u0026#39; SimpleCov::Formatter::LcovFormatter.config.report_with_single_file = true SimpleCov.formatter = SimpleCov::Formatter::LcovFormatter SimpleCov.start require \u0026#39;undercover\u0026#39; 最後に、CIツール(今回はGitHub Actions)の設定ファイルに、PRが作成された際にundercoverを実行するステップを追加します。 基本的にはフューチャーブランチでPRを作成するので、mainとのDiffカバレッジを取得するように設定します。\n1 2 3 4 5 6 7 8 9 10 11 12 # .github/workflows/test.yml steps: ~ 省略 ~ - name: Test run: bundle exec rspec - name: Diff Coverage run: | git fetch origin main undercover --compare origin/main PRがマージされる前に、undercoverが生成するレポートを確認し、Diffカバレッジが十分であることを確認します。\nまとめ undercover gemを導入することで、PR毎に新たに追加または変更されたコードがどの程度テストによってカバーされているかを正確に把握できるようになりました。これにより、テスト漏れが発生するリスクを減らし、コードの品質を継続的に向上させることができます。また、開発者は自分のコードが十分にテストされているかを自己確認できるため、品質意識の向上にも寄与します。\n参考 Support for \u0026ldquo;diff coverage\u0026rdquo; · Issue #886 · simplecov-ruby/simplecov grodowski/undercover ","date":"2024-04-02T16:22:47+09:00","image":"https://kseki.github.io/posts/pr%E6%AF%8E%E3%81%ABdiff%E3%82%AB%E3%83%90%E3%83%AC%E3%83%83%E3%82%B8%E3%82%92%E8%A8%88%E6%B8%AC%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/undercover.png","permalink":"https://kseki.github.io/posts/pr%E6%AF%8E%E3%81%ABdiff%E3%82%AB%E3%83%90%E3%83%AC%E3%83%83%E3%82%B8%E3%82%92%E8%A8%88%E6%B8%AC%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/","title":"PR毎にDiffカバレッジを計測する方法"},{"content":"概要 CodeRabbitというAIコードレビューサービスを試してみたので、良かったことなどをまとめました。\nAIコードレビュー | CodeRabbit\n良かったこと コードの品質向上に貢献してくれる。指摘だけではなく、コード提案もしてくれる。ボタンクリックで適用できるので便利だ。 コードの可読性やパフォーマンスに関する問題を指摘してくれる。長年スルーしていた問題を改めて指摘してくれるので、コードのメンテナンス性が高まる。 指摘コメントに対して、コメントでお願いすれば自動でissue作成してくれる。 ロジックの不備や考慮漏れを指摘してくれる。バグやエラーを防ぐことができる。 コメントを返信したら、CodeRabbitも返信をくれる。分からないところを聞くことで勉強になる。 悪かったこと 複数ファイル同じような変更をした時、ファイル数分同じ指摘コメントがつく。重複したコメントは不要だと思った。（XXと同じって書いてあるといちいち読み込まなくて済むと思った） Code Rabbitの費用対効果 CodeRabbit価格設定\n現在3人で開発しているので月額を試算してみます。\n1 $15/月 \\* 3人分 = $45/月 ⇒ 約6750円/月 もしレビュー専業の人を雇ったと仮定すると、\n1 週4h * 4週 * 5000円/時間 = 6万円/月 単純に比較するとCodeRabbitは人間のコードレビュアーに比べて非常に安価です。指摘の質も良く、費用対効果は高いです。\n継続するか 継続する！ 将来もっと良いAIコードレビューサービスが出てくるかもしれないので契約は月額のまま。 半年後にもう一度振り返り予定。 CodeRabbitはAIコードレビューとして優秀なサービスだと思う。コードの品質向上やタスク管理に役立つ機能が多い。 是非導入してみてはいかがでしょうか？\n","date":"2024-02-16T18:27:25+09:00","image":"https://kseki.github.io/posts/coderabbit/coderabbit.png","permalink":"https://kseki.github.io/posts/coderabbit/","title":"AIコードレビューのCodeRabbitを導入してみた"},{"content":"SKKとは SKK（エスケイケイ、Simple Kana to Kanji conversion program） Emacs上で動く、日本語入力システムの1つである 引用: SKK - Wikipedia\n既存IMEの問題点 形態素解析に基づいた自動変換で、文節を間違っていた場合にはカーソルキーで文節を変更する必要がある。その為、余計なキータイプが発生する。 SKKの特徴 かな漢字変換において形態素解析に基づいた変換を行わない。かなと漢字の境界をユーザが指定する。 ホームポジションを崩さず入力 シームレスな辞書登録 引用: SKK - Wikipedia\nAquaSKK 今回試したのは、AquaSKKというMacOSでもつかえるSKKベースのアプリケーションです。\nReleases · codefirst/aquaskk\nSKKの使い方 基本的にローマ字入力→ひらがなが一文字ずつ確定入力される(エンターいらず) 漢字変換するには、一文字目を大文字入力する必要がある 送りがななしのケース例： Kanjiと入力し、スペースキーで候補選択、次のキータイプ or エンターキーで確定する 送りがなありのケース例： OkuRiganaと入力し、スペースキーで候補選択、次のキータイプ or エンターキーで確定する 候補の漢字が無いケース: 自動的に辞書登録モードになる カタカナ入力するには、一文字目を大文字入力し、qキーを押す必要がある 例： Katakanaと入力し、qキー入力でカタカナになり、同時に確定する 良い所 キータイプ数が減る エンターキーを本来の目的のみで使える 即辞書登録できるのは良い 慣れると手書きと同じ感覚で使えるらしい 悪い所 今までの癖を抜くため相当な慣れが必要 シフトキー多用するので小指が疲れる ","date":"2022-03-05T23:04:37+09:00","permalink":"https://kseki.github.io/posts/hello-world/","title":"日本語入力が効率的になるというSSKを試してみた"},{"content":"概要 昨今の開発環境はほとんどのロジェクトでDocker Composeなどの仮想環境で構成されています。\n今回は、Neovim(Vim) + ALEを使ってDocker Compose上でRubocopを実行する方法を書きました。\nバージョン Neovim: v0.6.0 ALE: v3.1.0 Docker Compose: 1.24.0 設定方法 前提として、ALEプラグインをインストール済みの状態であることとします。\nまず、Railsのbinstubとしてbin/rubocopにDocker Compose上でRubocopを実行するスクリプトを作成します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/env ruby require \u0026#39;pathname\u0026#39; require \u0026#39;fileutils\u0026#39; include FileUtils APP_ROOT = Pathname.new File.expand_path(\u0026#39;../../\u0026#39;, __FILE__) chdir APP_ROOT do rubocop_command = \u0026#34;bundle exec rubocop #{ARGV.join(\u0026#39; \u0026#39;)}\u0026#34; system(\u0026#34;docker-compose exec -T app #{rubocop_command}\u0026#39;\u0026#34;) end ALEはRubocopの結果をJSON形式で受け取って処理します。その際、標準出力に余計な出力がないよう、docker-compose execコマンドに-Tオプションを指定しています。\nNeovimの設定 最後にNeovimの設定をします。\n開発環境はプロジェクトによって異なるので、僕はthinca/vim-localrcを使って.local.vimrcに設定をしています。\n1. 実行コマンドにbin/rubocopを指定 1 let g:ale_ruby_rubocop_executable = \u0026#39;bin/rubocop\u0026#39; こちらは説明不要ですね。\n2. ファイル名のマッピング 1 2 3 4 5 let g:ale_filename_mappings = { \\ \u0026#39;rubocop\u0026#39;: [ \\ [\u0026#39;/Users/kseki/rails-project\u0026#39;, \u0026#39;/opt\u0026#39;], \\ ], \\} そのままだとローカルの絶対パスをbin/rubocopコマンドの引数として渡してしまうが、実行するのはDocker上です。 Docker上の絶対パスに変換してから渡すようにマッピング指定をします。 ['/Users/kseki/rails-project', '/opt'] の部分です。左はローカルのプロジェクトルートパス、右はDocker上のプロジェクトルートパスです。\nまとめ Gistにまとめました！ Setting up \u0026ldquo;Rubocop\u0026rdquo; to run on \u0026ldquo;Docker compose\u0026rdquo; using \u0026ldquo;ALE\u0026rdquo;\n参考 dense-analysis/ale: Check syntax in Vim asynchronously and fix files, with Language Server Protocol (LSP) support Vim, ALE, Docker, and Per-Project Linting | Ryan McGrath ","date":"2022-01-20T00:00:00Z","image":"https://kseki.github.io/posts/ale-vim-rubocop-on-docker-compose/vim-ale-rubocop.png","permalink":"https://kseki.github.io/posts/ale-vim-rubocop-on-docker-compose/","title":"NeovimでALEを使ってDocker Compose上でRubocopを実行する"},{"content":"概要 https接続するために自己証明書(オレオレ証明書)を作成するのはまぁ手間がかかります。\nしかし、localhostというGemを使えばSSL証明書を自作せずにRailsの開発環境でhttps接続できます。\n今回のコードはこちら。\nRuby: 3.0.2 Ruby on Rails: 7.0.0 Puma: 5.5.2 localhost: 1.1.9 localhost Gemとは localhost Gemとは、Gemを追加するだけでhttps://localhost:8080のようにSSL接続できる便利なライブラリです。\n自動的に秘密鍵及び、自己証明書（オレオレ証明書）を作成してくれます。\n設定方法 開発環境だけlocalhost Gemを使いたいので、GemfileのdevelopmentグループブロックにGemを追加。\n1 2 3 4 # Gemfile group :development do gem \u0026#39;localhost\u0026#39; end 実行 Pumaコマンドであれば、Gem追加だけでhttps接続ができます。\n1 2 3 4 5 6 7 8 9 10 11 $ bundle exec puma -b \u0026#39;ssl://localhost:9292\u0026#39; config.ru Puma starting in single mode... * Puma version: 5.5.2 (ruby 3.0.2-p107) (\u0026#34;Zawgyi\u0026#34;) * Min threads: 5 * Max threads: 5 * Environment: development * PID: 14848 * Listening on ssl://127.0.0.1:9292? * Listening on ssl://[::1]:9292? Use Ctrl-C to stop ただ、これだとアプリケーションログはlog/development.logに出力されるので、別タブを開いてtailコマンド等で参照するしかありません。 rails serverで実行できた方が何かと便利です。\nRails serverで動かす Pumaの設定ファイルにSSL接続の設定を追加します。\nRailsデフォルトの設定で3000番ポートは使われているので3001番ポートを指定します。\n1 2 3 4 5 6 7 8 # config/puma.rb require \u0026#39;localhost/authority\u0026#39; authority = Localhost::Authority.fetch ssl_bind \u0026#39;127.0.0.1\u0026#39;, \u0026#39;3001\u0026#39;, { key: authority.key_path, cert: authority.certificate_path } Railsコマンドで実行する。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ bundle exec rails server =\u0026gt; Booting Puma =\u0026gt; Rails 7.0.0 application starting in development =\u0026gt; Run `bin/rails server --help` for more startup options Puma starting in single mode... * Puma version: 5.5.2 (ruby 3.0.2-p107) (\u0026#34;Zawgyi\u0026#34;) * Min threads: 5 * Max threads: 5 * Environment: development * PID: 17087 * Listening on ssl://127.0.0.1:3001?cert=/Users/kseki/.localhost/localhost.crt\u0026amp;key=/Users/kseki/.localhost/localhost.key\u0026amp;verify_mode=none * Listening on http://127.0.0.1:3000 * Listening on http://[::1]:3000 Use Ctrl-C to stop リスニングしているポートが２つあります。\nhttps://localhost:3001にアクセスすると続けてアプリケーションログも出力されます。\n1 2 3 4 5 6 7 Started GET \u0026#34;/\u0026#34; for 127.0.0.1 at 2021-12-31 23:20:45 +0900 Processing by HomeController#index as HTML Rendering layout layouts/application.html.erb Rendering home/index.html.erb within layouts/application Rendered home/index.html.erb within layouts/application (Duration: 0.0ms | Allocations: 15) Rendered layout layouts/application.html.erb (Duration: 0.6ms | Allocations: 484) Completed 200 OK in 1ms (Views: 1.0ms | Allocations: 733) 当然http://localhost:3000にアクセスしても動きます。\nポート3000番で接続したい 更にhttpsだけで接続するようにするにはPumaの設定を変更します。\nssl_bindメソッドの引数を3001から3000に変更 PORT指定行をコメントアウト 1 2 3 4 5 6 7 # config/puma.rb - ssl_bind \u0026#39;127.0.0.1\u0026#39;, \u0026#39;3001\u0026#39;, { + ssl_bind \u0026#39;127.0.0.1\u0026#39;, \u0026#39;3000\u0026#39;, { - port ENV.fetch(\u0026#34;PORT\u0026#34;) { 3000 } + # port ENV.fetch(\u0026#34;PORT\u0026#34;) { 3000 } 1 2 3 4 5 6 7 8 9 10 11 12 13 $ bundle exec rails server =\u0026gt; Booting Puma =\u0026gt; Rails 7.0.0 application starting in development =\u0026gt; Run `bin/rails server --help` for more startup options Puma starting in single mode... * Puma version: 5.5.2 (ruby 3.0.2-p107) (\u0026#34;Zawgyi\u0026#34;) * Min threads: 5 * Max threads: 5 * Environment: development * PID: 20097 * Listening on ssl://127.0.0.1:3000?cert=/Users/kseki/.localhost/localhost.crt\u0026amp;key=/Users/kseki/.localhost/localhost.key\u0026amp;verify_mode=none Use Ctrl-C to stop https://localhost:3000にアクセスすると続けてアプリケーションログが出力されます。\n1 2 3 4 5 6 7 Started GET \u0026#34;/\u0026#34; for 127.0.0.1 at 2021-12-31 23:28:51 +0900 Processing by HomeController#index as HTML Rendering layout layouts/application.html.erb Rendering home/index.html.erb within layouts/application Rendered home/index.html.erb within layouts/application (Duration: 1.4ms | Allocations: 448) Rendered layout layouts/application.html.erb (Duration: 4.6ms | Allocations: 1473) Completed 200 OK in 12ms (Views: 8.2ms | Allocations: 4696) まとめ Gistに必要箇所だけまとめたので御覧ください。\n参考 socketry/localhost socketry/localhost: Localhost::Authority puma/puma: Self-signed SSL certificates (via the localhost gem, for development use) Method: Puma::DSL#ssl_bind — Documentation for puma (5.5.2) パーフェクト Ruby on Rails 【増補改訂版】 (Perfect series) Amazonで購入 SSL/TLS実践入門──Webの安全性を支える暗号化技術の設計思想 WEB\u0026#43;DB PRESS plus Amazonで購入 ","date":"2021-12-31T00:00:00Z","permalink":"https://kseki.github.io/posts/rails-ssl-connection-with-localhost-gem/","title":"SSL証明書を自作せずに、Railsの開発環境でhttps接続する方法"}]